{"version":3,"sources":["com/fulcrologic/fulcro/algorithms/normalized_state.cljc"],"mappings":"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","names":["com.fulcrologic.fulcro.algorithms.normalized-state/integrate-ident","com.fulcrologic.fulcro.algorithms.data-targeting/integrate-ident*","com.fulcrologic.fulcro.algorithms.normalized-state/remove-ident","com.fulcrologic.fulcro.algorithms.merge/remove-ident*","com.fulcrologic.fulcro.algorithms.normalized-state/tree-path->db-path","state","path","G__50911","vec__50912","seq__50913","cljs.core/seq","first__50914","cljs.core/first","cljs.core/next","vec__50918","seq__50919","first__50920","h","t","new-path","np","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","c","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","edn-query-language.core/ident?","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","var_args","G__50922","com.fulcrologic.fulcro.algorithms.normalized-state/get-in-graph","js/Error","state-map","com.fulcrologic.fulcro.algorithms.normalized_state.get_in_graph.cljs$core$IFn$_invoke$arity$3","not-found","cljs.core.get_in.cljs$core$IFn$_invoke$arity$3","G__50924","com.fulcrologic.fulcro.algorithms.normalized-state/ui->props","this","com.fulcrologic.fulcro.algorithms.normalized_state.ui__GT_props.cljs$core$IFn$_invoke$arity$3","com.fulcrologic.fulcro.components/component->state-map","com.fulcrologic.fulcro.components/react-type","com.fulcrologic.fulcro.components/get-ident","component-class","ident","com.fulcrologic.fulcro.algorithms.denormalize/db->tree","com.fulcrologic.fulcro.components.get_query.cljs$core$IFn$_invoke$arity$2","com.fulcrologic.fulcro.algorithms.normalized_state.get_in_graph.cljs$core$IFn$_invoke$arity$2","p__50925","vec__50926","seq__50927","first__50928","com.fulcrologic.fulcro.algorithms.normalized-state/dissoc-in","m","k","ks","keys","temp__5802__auto__","nextmap","cljs.core.get.cljs$core$IFn$_invoke$arity$2","newmap","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","G__50933","com.fulcrologic.fulcro.algorithms.normalized-state/remove-entity","com.fulcrologic.fulcro.algorithms.normalized_state.remove_entity.cljs$core$IFn$_invoke$arity$3","cascade","normalized-paths","ps","cljs.core/reduce-kv","v","cljs.core/map?","paths*","p1__50929#","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core/count","ident-specific-paths","a-path","vl","cljs.core/coll?","or__4131__auto__","cljs.core/some","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","remove-ident-at-path","a-normalized-path","cljs.core/every?","remove-ident-from-tables","p1__50930#","p2__50931#","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","state-without-entity","target-entity","cascaded-idents","table-key","cljs.core.map.cljs$core$IFn$_invoke$arity$2","entity-field","clojure.set.intersection.cljs$core$IFn$_invoke$arity$2","cljs.core/set","cljs.core/keys","final-state","edge","new-state","G__50938","com.fulcrologic.fulcro.algorithms.normalized-state/sort-idents-by","vector-of-idents","sortkey-fn","comp-fn","kfn","G__50939","cljs.core/vec","cljs.core.sort_by.cljs$core$IFn$_invoke$arity$3","com.fulcrologic.fulcro.algorithms.normalized_state.sort_idents_by.cljs$core$IFn$_invoke$arity$4","cljs.core/compare","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","com.fulcrologic.fulcro.algorithms.normalized-state/update-caller!","p__50942","map__50943","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","seq50940","G__50941","self__4717__auto__","ref","args","cljs.core.apply.cljs$core$IFn$_invoke$arity$5","cljs.core/swap!","cljs.core/update-in","com.fulcrologic.fulcro.algorithms.normalized-state/update-caller-in!","p__50948","map__50949","seq50945","G__50946","G__50947","mutation-env","cljs.core/deref","cljs.core.into.cljs$core$IFn$_invoke$arity$2","and__4120__auto__"],"sourcesContent":["(ns com.fulcrologic.fulcro.algorithms.normalized-state\n  \"Functions that can be used against a normalized Fulcro state database. This namespace also includes some handy aliases\n   to useful functions that work on normalized state from other namespaces.\"\n  #?(:cljs (:require-macros com.fulcrologic.fulcro.algorithms.normalized-state))\n  (:require\n    [clojure.set :as set]\n    [com.fulcrologic.fulcro.components :as comp]\n    [edn-query-language.core :as eql]\n    [clojure.spec.alpha :as s]\n    [com.fulcrologic.guardrails.core :refer [>defn =>]]\n    [com.fulcrologic.fulcro.algorithms.data-targeting :as targeting]\n    [com.fulcrologic.fulcro.algorithms.denormalize :as fdn]\n    [com.fulcrologic.fulcro.algorithms.merge :as merge]))\n\n(def integrate-ident\n  \"[state ident & named-parameters]\n\n  Integrate an ident into any number of places in the app state. This function is safe to use within mutation\n  implementations as a general helper function.\n\n  The named parameters can be specified any number of times. They are:\n\n  - append:  A vector (path) to a list in your app state where this new object's ident should be appended. Will not append\n  the ident if that ident is already in the list.\n  - prepend: A vector (path) to a list in your app state where this new object's ident should be prepended. Will not place\n  the ident if that ident is already in the list.\n  - replace: A vector (path) to a specific location in app-state where this object's ident should be placed. Can target a to-one or to-many.\n   If the target is a vector element then that element must already exist in the vector.\n\n  NOTE: `ident` does not have to be an ident if you want to place denormalized data.  It can really be anything.\n\n  Returns the updated state map.\"\n  targeting/integrate-ident*)\n\n(def remove-ident\n  \" [state-map ident path-to-idents]\n\n  Removes an ident, if it exists, from a list of idents in app state. This\n  function is safe to use within mutations.\"\n  merge/remove-ident*)\n\n\n(>defn tree-path->db-path\n  \"Convert a 'denormalized' path into a normalized one by walking the path in state treating ident-based edges\n  as jumps back to that location in state-map.\n\n  For example, one might find this to be true for a normalized db:\n\n  ```\n  state => {:person/id {1 {:person/id 1 :person/spouse [:person/id 3]}\n                        3 {:person/id 3 :person/first-name ...}}}\n\n  (tree-path->db-path state [:person/id 1 :person/spouse :person/first-name])\n  => [:person/id 3 :person/first-name]\n  ```\n  \"\n  ([state path]\n   [map? vector? => vector?]\n   (loop [[h & t] path\n          new-path []]\n     (if h\n       (let [np (conj new-path h)\n             c  (get-in state np)]\n         (if (eql/ident? c)\n           (recur t c)\n           (recur t (conj new-path h))))\n       (if (not= path new-path)\n         new-path\n         path)))))\n\n\n(>defn get-in-graph\n  \"Like clojure.core/get-in, but as it traverses the path it will follow idents in the state-map. This makes it similar\n   to a very targeted `db->tree`, but allows you to get something along a particular path without needing to parse a query.\n\n   Returns the data at the path, `not-found` (if specified) if nothing is found; otherwise nil.\n\n   See also `tree-path->db-path`.\"\n  ([state-map path]\n   [map? vector? => any?]\n   (get-in-graph state-map path nil))\n\n  ([state-map path not-found]\n   [map? vector? any? => any?]\n   (get-in state-map (tree-path->db-path state-map path) not-found)))\n\n\n(defn ui->props\n  \"Obtain a tree of props for a UI instance from the current application state. Useful in mutations where you want\n   to denormalize an entity from the state database. `this` can often be obtained from the mutation `env` at the\n  `:component` key.\"\n  ([this]\n   (ui->props (comp/component->state-map this) (comp/react-type this) (comp/get-ident this)))\n  ([state-map component-class ident]\n   (fdn/db->tree (comp/get-query component-class state-map) (get-in-graph state-map ident) state-map)))\n\n\n(defn dissoc-in\n  \"Dissociates an entry from a nested associative structure returning a new\n   nested structure. keys is a sequence of keys. Any empty maps that result\n   will not be present in the new structure.\n\n   The `ks` is *not* ident-aware. This function is here simply because it\n   is often needed, and clojure.core does not supply it.\n   \"\n  [m [k & ks :as keys]]\n  (if ks\n    (if-let [nextmap (get m k)]\n      (let [newmap (dissoc-in nextmap ks)]\n        (if (seq newmap)\n          (assoc m k newmap)\n          (dissoc m k)))\n      m)\n    (dissoc m k)))\n\n(>defn remove-entity\n  \"Remove the given entity at the given ident. Also scans all tables and removes any to-one or to-many idents that are\n  found that match `ident` (removes dangling pointers to the removed entity).\n\n  The optional `cascade` parameter is a set of keywords that represent edges that should cause recursive deletes\n  (i.e. it indicates edge names that *own* something, indicating it is safe to remove those entities as well).\n\n  Returns the new state map with the entity(ies) removed.\"\n\n  ([state-map ident]\n   [map? eql/ident? => map?]\n   (remove-entity state-map ident #{}))\n\n  ([state-map ident cascade]\n   [map? eql/ident? (s/coll-of keyword? :kind set?) => map?]\n\n   (let [;; \"Walks the tree in a depth first manner and returns the normalized possible paths\"\n         normalized-paths         (letfn [(paths* [ps ks m]\n                                            (reduce-kv\n                                              (fn [ps k v]\n                                                (if (map? v)\n                                                  (paths* ps (conj ks k) v)\n                                                  (conj ps (conj ks k))))\n                                              ps\n                                              m))]\n                                    (filter #(< (count %) 4)\n                                      (paths* () [] state-map)))\n\n         ident-specific-paths     (fn [state ident]\n                                    (filter (fn [a-path]\n                                              (let [vl (get-in state a-path)]\n                                                (if (coll? vl)\n                                                  (or\n                                                    (some #{ident} vl)\n                                                    (= ident vl)))))\n                                      normalized-paths))\n\n         remove-ident-at-path     (fn [state a-normalized-path ident]\n                                    (let [v (get-in state a-normalized-path)]\n                                      (if (coll? v)\n                                        (cond\n                                          (= v ident) (dissoc-in state a-normalized-path)\n                                          (every? eql/ident? v) (merge/remove-ident* state ident a-normalized-path)\n                                          :else state)\n                                        state)))\n\n\n         remove-ident-from-tables (fn [state ident]\n                                    (reduce #(remove-ident-at-path %1 %2 ident)\n                                      state\n                                      (ident-specific-paths state ident)))\n\n         state-without-entity     (->\n                                    ;; remove pointers to the entity\n                                    (remove-ident-from-tables state-map ident)\n                                    ;; remove the top-level entity\n                                    (dissoc-in ident))\n\n         target-entity            (get-in-graph state-map ident)\n\n         ;; Computed set of all affected entities when cascade option is provided\n         cascaded-idents          (let [table-key (first ident)]\n                                    (map\n                                      (fn [entity-field]\n                                        (get-in state-map\n                                          (conj [table-key (table-key target-entity)] entity-field)))\n                                      (set/intersection\n                                        cascade\n                                        (set (keys target-entity)))))\n\n         final-state              (reduce\n                                    (fn [state edge]\n                                      (if (every? eql/ident? edge)\n                                        (reduce (fn [new-state ident] (remove-entity new-state ident cascade)) state edge)\n                                        (remove-entity state edge cascade)))\n                                    state-without-entity\n                                    cascaded-idents)]\n\n     final-state)))\n\n\n;; This one isn't quite right yet...hold off\n#_(>defn remove-edge\n    \"Remove the given edge at the given path. Also scans all tables and removes any to-one or to-many idents that are\n    found that match `edge` (removes dangling pointers to the removed entity(ies).\n\n    The optional `cascade` parameter is a set of keywords that represent edges that should cause recursive deletes\n    (i.e. it indicates edge names that *own* something, indicating it is safe to remove those entities as well).\n\n    Returns the new state map with the entity(ies) removed.\"\n\n    ([state-map path-to-edge]\n     [map? vector? => any?]\n     (remove-edge state-map path-to-edge #{}))\n\n\n    ([state-map path-to-edge cascade]\n     [map? vector? (s/coll-of keyword? :kind set?) => map?]\n     (let [;; \"Walks the tree in a depth first manner and returns the normalized possible paths\"\n           normalized-paths (letfn [(paths* [ps ks m]\n                                      (reduce-kv\n                                        (fn [ps k v]\n                                          (if (map? v)\n                                            (paths* ps (conj ks k) v)\n                                            (conj ps (conj ks k))))\n                                        ps\n                                        m))]\n                              (filter #(< (count %) 4)\n                                (paths* () [] state-map)))\n\n           candidate        (let [vl (get-in state-map path-to-edge)]\n                              (if-not (vector? vl)\n                                nil\n                                (cond\n                                  (eql/ident? vl) [vl]\n                                  (every? eql/ident? vl) vl)))\n\n           final-state      (if (some #{path-to-edge} normalized-paths)\n                              (reduce\n                                #(remove-entity %1 %2 cascade)\n                                state-map\n                                candidate)\n                              state-map)]\n       final-state)))\n\n\n(>defn sort-idents-by\n  \"Returns the sorted version of the provided vector of idents.\n\n  Intended to be used as\n  ```\n  (sort-idents-by people-idents :person/name)\n  ```\n\n  NOTE: The order of parameters is different from clojure.core/sort-by to facilitate:\n\n  ```\n  (swap! state update-in [:person/id 1 :person/children]\n    (partial sort-idents-by @state) :person/first-name)\n\n  ```\n\n  You can optionally pass a `comp-fn` which is as-described in `sort-by`.\n  \"\n  ([state-map vector-of-idents sortkey-fn comp-fn]\n   [map? (s/every eql/ident? :kind vector?) ifn? ifn? => any?]\n   (let [kfn (fn [ident] (sortkey-fn (get-in state-map ident)))]\n     (vec (sort-by kfn comp-fn vector-of-idents))))\n  ([state-map vector-of-idents sortkey-fn]\n   [map? (s/every eql/ident? :kind vector?) ifn? => any?]\n   (sort-idents-by state-map vector-of-idents sortkey-fn compare)))\n\n\n(defn update-caller!\n  \"Runs clojure.core/update on the table entry in the state database that corresponds\n   to the mutation caller (which can be explicitly set via `:ref` when calling `transact!`).\n\n   Equivalent to\n   ```\n   (apply swap! (:state env) update-in (:ref env) ...)\n   ```\n   \"\n\n  [{:keys [state ref]} & args]\n  (apply swap! state update-in ref args))\n\n\n(defn update-caller-in!\n  \"Like swap! but starts at the ref from `env`, adds in supplied `path` elements\n  (resolving across idents if necessary). Finally runs an update-in on that resultant\n  path with the given `args`.\n\n   Equivalent to:\n   ```\n   (swap! (:state env) update-in (tree-path->db-path @state (into (:ref env) path)) args)\n   ```\n   with a small bit of additional sanity checking.\"\n\n  [{:keys [state ref] :as mutation-env} path & args]\n  (let [path (tree-path->db-path @state (into ref path))]\n    (if (and path (get-in-graph @state path))\n      (apply swap! state update-in path args)\n      @state)))\n\n#?(:clj\n   (defmacro swap!->\n     \"A useful macro for threading multiple operations together on an atom (e.g. state atom in mutation)\n\n     Equivalent to:\n     ```\n     (swap! atom (fn [s] (-> s ...forms...)))\n     ```\n\n     For example\n\n     ```\n     (swap!-> (:state env)\n       (merge/merge-component ...)\n       (integrate-ident* ...))\n     ```\n     \"\n     [atom & forms]\n     `(swap! ~atom (fn [s#] (-> s# ~@forms)))))\n"]}