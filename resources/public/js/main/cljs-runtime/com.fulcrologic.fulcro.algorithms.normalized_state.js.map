{"version":3,"sources":["com/fulcrologic/fulcro/algorithms/normalized_state.cljc"],"mappings":"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","names":["com.fulcrologic.fulcro.algorithms.normalized-state/integrate-ident","com.fulcrologic.fulcro.algorithms.data-targeting/integrate-ident*","com.fulcrologic.fulcro.algorithms.normalized-state/remove-ident","com.fulcrologic.fulcro.algorithms.merge/remove-ident*","com.fulcrologic.fulcro.algorithms.normalized-state/tree-path->db-path","state","path","G__56783","vec__56785","seq__56786","cljs.core/seq","first__56787","cljs.core/first","cljs.core/next","vec__56793","seq__56794","first__56795","h","t","new-path","np","cljs.core.conj","c","cljs.core.get_in","edn-query-language.core/ident?","cljs.core.not_EQ_","var_args","G__56810","com.fulcrologic.fulcro.algorithms.normalized-state/get-in-graph","js/Error","state-map","com.fulcrologic.fulcro.algorithms.normalized_state.get_in_graph","not-found","G__56814","com.fulcrologic.fulcro.algorithms.normalized-state/ui->props","this","com.fulcrologic.fulcro.algorithms.normalized_state.ui__GT_props","com.fulcrologic.fulcro.components/component->state-map","com.fulcrologic.fulcro.components/react-type","com.fulcrologic.fulcro.components/get-ident","component-class","ident","com.fulcrologic.fulcro.algorithms.denormalize/db->tree","com.fulcrologic.fulcro.components.get_query","p__56815","vec__56816","seq__56817","first__56818","com.fulcrologic.fulcro.algorithms.normalized-state/dissoc-in","m","k","ks","keys","temp__5802__auto__","nextmap","cljs.core.get","newmap","cljs.core.assoc","cljs.core.dissoc","G__56823","com.fulcrologic.fulcro.algorithms.normalized-state/remove-entity","com.fulcrologic.fulcro.algorithms.normalized_state.remove_entity","cascade","normalized-paths","ps","cljs.core/reduce-kv","v","cljs.core/map?","paths*","p1__56819#","cljs.core.filter","cljs.core/count","ident-specific-paths","a-path","vl","cljs.core/coll?","or__5045__auto__","cljs.core/some","cljs.core._EQ_","remove-ident-at-path","a-normalized-path","cljs.core/every?","remove-ident-from-tables","p1__56820#","p2__56821#","cljs.core.reduce","state-without-entity","target-entity","cascaded-idents","table-key","cljs.core.map","entity-field","clojure.set.intersection","cljs.core/set","cljs.core/keys","final-state","edge","new-state","G__56846","com.fulcrologic.fulcro.algorithms.normalized-state/sort-idents-by","vector-of-idents","sortkey-fn","comp-fn","kfn","G__56850","cljs.core/vec","cljs.core.sort_by","com.fulcrologic.fulcro.algorithms.normalized_state.sort_idents_by","cljs.core/compare","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","com.fulcrologic.fulcro.algorithms.normalized-state/update-caller!","p__56858","map__56859","cljs.core/--destructure-map","seq56854","G__56855","self__5754__auto__","ref","args","cljs.core.apply","cljs.core/swap!","cljs.core/update-in","com.fulcrologic.fulcro.algorithms.normalized-state/update-caller-in!","p__56863","map__56864","seq56860","G__56861","G__56862","mutation-env","cljs.core/deref","cljs.core.into","and__5043__auto__"],"sourcesContent":["(ns com.fulcrologic.fulcro.algorithms.normalized-state\n  \"Functions that can be used against a normalized Fulcro state database. This namespace also includes some handy aliases\n   to useful functions that work on normalized state from other namespaces.\"\n  #?(:cljs (:require-macros com.fulcrologic.fulcro.algorithms.normalized-state))\n  (:require\n    [clojure.set :as set]\n    [com.fulcrologic.fulcro.components :as comp]\n    [edn-query-language.core :as eql]\n    [clojure.spec.alpha :as s]\n    [com.fulcrologic.guardrails.core :refer [>defn =>]]\n    [com.fulcrologic.fulcro.algorithms.data-targeting :as targeting]\n    [com.fulcrologic.fulcro.algorithms.denormalize :as fdn]\n    [com.fulcrologic.fulcro.algorithms.merge :as merge]))\n\n(def integrate-ident\n  \"[state ident & named-parameters]\n\n  Integrate an ident into any number of places in the app state. This function is safe to use within mutation\n  implementations as a general helper function.\n\n  The named parameters can be specified any number of times. They are:\n\n  - append:  A vector (path) to a list in your app state where this new object's ident should be appended. Will not append\n  the ident if that ident is already in the list.\n  - prepend: A vector (path) to a list in your app state where this new object's ident should be prepended. Will not place\n  the ident if that ident is already in the list.\n  - replace: A vector (path) to a specific location in app-state where this object's ident should be placed. Can target a to-one or to-many.\n   If the target is a vector element then that element must already exist in the vector.\n\n  NOTE: `ident` does not have to be an ident if you want to place denormalized data.  It can really be anything.\n\n  Returns the updated state map.\"\n  targeting/integrate-ident*)\n\n(def remove-ident\n  \" [state-map ident path-to-idents]\n\n  Removes an ident, if it exists, from a list of idents in app state. This\n  function is safe to use within mutations.\"\n  merge/remove-ident*)\n\n\n(>defn tree-path->db-path\n  \"Convert a 'denormalized' path into a normalized one by walking the path in state treating ident-based edges\n  as jumps back to that location in state-map.\n\n  For example, one might find this to be true for a normalized db:\n\n  ```\n  state => {:person/id {1 {:person/id 1 :person/spouse [:person/id 3]}\n                        3 {:person/id 3 :person/first-name ...}}}\n\n  (tree-path->db-path state [:person/id 1 :person/spouse :person/first-name])\n  => [:person/id 3 :person/first-name]\n  ```\n  \"\n  ([state path]\n   [map? vector? => vector?]\n   (loop [[h & t] path\n          new-path []]\n     (if h\n       (let [np (conj new-path h)\n             c  (get-in state np)]\n         (if (eql/ident? c)\n           (recur t c)\n           (recur t (conj new-path h))))\n       (if (not= path new-path)\n         new-path\n         path)))))\n\n\n(>defn get-in-graph\n  \"Like clojure.core/get-in, but as it traverses the path it will follow idents in the state-map. This makes it similar\n   to a very targeted `db->tree`, but allows you to get something along a particular path without needing to parse a query.\n\n   Returns the data at the path, `not-found` (if specified) if nothing is found; otherwise nil.\n\n   See also `tree-path->db-path`.\"\n  ([state-map path]\n   [map? vector? => any?]\n   (get-in-graph state-map path nil))\n\n  ([state-map path not-found]\n   [map? vector? any? => any?]\n   (get-in state-map (tree-path->db-path state-map path) not-found)))\n\n\n(defn ui->props\n  \"Obtain a tree of props for a UI instance from the current application state. Useful in mutations where you want\n   to denormalize an entity from the state database. `this` can often be obtained from the mutation `env` at the\n  `:component` key.\"\n  ([this]\n   (ui->props (comp/component->state-map this) (comp/react-type this) (comp/get-ident this)))\n  ([state-map component-class ident]\n   (fdn/db->tree (comp/get-query component-class state-map) (get-in-graph state-map ident) state-map)))\n\n\n(defn dissoc-in\n  \"Dissociates an entry from a nested associative structure returning a new\n   nested structure. keys is a sequence of keys. Any empty maps that result\n   will not be present in the new structure.\n\n   The `ks` is *not* ident-aware. This function is here simply because it\n   is often needed, and clojure.core does not supply it.\n   \"\n  [m [k & ks :as keys]]\n  (if ks\n    (if-let [nextmap (get m k)]\n      (let [newmap (dissoc-in nextmap ks)]\n        (if (seq newmap)\n          (assoc m k newmap)\n          (dissoc m k)))\n      m)\n    (dissoc m k)))\n\n(>defn remove-entity\n  \"Remove the given entity at the given ident. Also scans all tables and removes any to-one or to-many idents that are\n  found that match `ident` (removes dangling pointers to the removed entity).\n\n  The optional `cascade` parameter is a set of keywords that represent edges that should cause recursive deletes\n  (i.e. it indicates edge names that *own* something, indicating it is safe to remove those entities as well).\n\n  Returns the new state map with the entity(ies) removed.\"\n\n  ([state-map ident]\n   [map? eql/ident? => map?]\n   (remove-entity state-map ident #{}))\n\n  ([state-map ident cascade]\n   [map? eql/ident? (s/coll-of keyword? :kind set?) => map?]\n\n   (let [;; \"Walks the tree in a depth first manner and returns the normalized possible paths\"\n         normalized-paths         (letfn [(paths* [ps ks m]\n                                            (reduce-kv\n                                              (fn [ps k v]\n                                                (if (map? v)\n                                                  (paths* ps (conj ks k) v)\n                                                  (conj ps (conj ks k))))\n                                              ps\n                                              m))]\n                                    (filter #(< (count %) 4)\n                                      (paths* () [] state-map)))\n\n         ident-specific-paths     (fn [state ident]\n                                    (filter (fn [a-path]\n                                              (let [vl (get-in state a-path)]\n                                                (if (coll? vl)\n                                                  (or\n                                                    (some #{ident} vl)\n                                                    (= ident vl)))))\n                                      normalized-paths))\n\n         remove-ident-at-path     (fn [state a-normalized-path ident]\n                                    (let [v (get-in state a-normalized-path)]\n                                      (if (coll? v)\n                                        (cond\n                                          (= v ident) (dissoc-in state a-normalized-path)\n                                          (every? eql/ident? v) (merge/remove-ident* state ident a-normalized-path)\n                                          :else state)\n                                        state)))\n\n\n         remove-ident-from-tables (fn [state ident]\n                                    (reduce #(remove-ident-at-path %1 %2 ident)\n                                      state\n                                      (ident-specific-paths state ident)))\n\n         state-without-entity     (->\n                                    ;; remove pointers to the entity\n                                    (remove-ident-from-tables state-map ident)\n                                    ;; remove the top-level entity\n                                    (dissoc-in ident))\n\n         target-entity            (get-in-graph state-map ident)\n\n         ;; Computed set of all affected entities when cascade option is provided\n         cascaded-idents          (let [table-key (first ident)]\n                                    (map\n                                      (fn [entity-field]\n                                        (get-in state-map\n                                          (conj [table-key (table-key target-entity)] entity-field)))\n                                      (set/intersection\n                                        cascade\n                                        (set (keys target-entity)))))\n\n         final-state              (reduce\n                                    (fn [state edge]\n                                      (if (every? eql/ident? edge)\n                                        (reduce (fn [new-state ident] (remove-entity new-state ident cascade)) state edge)\n                                        (remove-entity state edge cascade)))\n                                    state-without-entity\n                                    cascaded-idents)]\n\n     final-state)))\n\n\n;; This one isn't quite right yet...hold off\n#_(>defn remove-edge\n    \"Remove the given edge at the given path. Also scans all tables and removes any to-one or to-many idents that are\n    found that match `edge` (removes dangling pointers to the removed entity(ies).\n\n    The optional `cascade` parameter is a set of keywords that represent edges that should cause recursive deletes\n    (i.e. it indicates edge names that *own* something, indicating it is safe to remove those entities as well).\n\n    Returns the new state map with the entity(ies) removed.\"\n\n    ([state-map path-to-edge]\n     [map? vector? => any?]\n     (remove-edge state-map path-to-edge #{}))\n\n\n    ([state-map path-to-edge cascade]\n     [map? vector? (s/coll-of keyword? :kind set?) => map?]\n     (let [;; \"Walks the tree in a depth first manner and returns the normalized possible paths\"\n           normalized-paths (letfn [(paths* [ps ks m]\n                                      (reduce-kv\n                                        (fn [ps k v]\n                                          (if (map? v)\n                                            (paths* ps (conj ks k) v)\n                                            (conj ps (conj ks k))))\n                                        ps\n                                        m))]\n                              (filter #(< (count %) 4)\n                                (paths* () [] state-map)))\n\n           candidate        (let [vl (get-in state-map path-to-edge)]\n                              (if-not (vector? vl)\n                                nil\n                                (cond\n                                  (eql/ident? vl) [vl]\n                                  (every? eql/ident? vl) vl)))\n\n           final-state      (if (some #{path-to-edge} normalized-paths)\n                              (reduce\n                                #(remove-entity %1 %2 cascade)\n                                state-map\n                                candidate)\n                              state-map)]\n       final-state)))\n\n\n(>defn sort-idents-by\n  \"Returns the sorted version of the provided vector of idents.\n\n  Intended to be used as\n  ```\n  (sort-idents-by people-idents :person/name)\n  ```\n\n  NOTE: The order of parameters is different from clojure.core/sort-by to facilitate:\n\n  ```\n  (swap! state update-in [:person/id 1 :person/children]\n    (partial sort-idents-by @state) :person/first-name)\n\n  ```\n\n  You can optionally pass a `comp-fn` which is as-described in `sort-by`.\n  \"\n  ([state-map vector-of-idents sortkey-fn comp-fn]\n   [map? (s/every eql/ident? :kind vector?) ifn? ifn? => any?]\n   (let [kfn (fn [ident] (sortkey-fn (get-in state-map ident)))]\n     (vec (sort-by kfn comp-fn vector-of-idents))))\n  ([state-map vector-of-idents sortkey-fn]\n   [map? (s/every eql/ident? :kind vector?) ifn? => any?]\n   (sort-idents-by state-map vector-of-idents sortkey-fn compare)))\n\n\n(defn update-caller!\n  \"Runs clojure.core/update on the table entry in the state database that corresponds\n   to the mutation caller (which can be explicitly set via `:ref` when calling `transact!`).\n\n   Equivalent to\n   ```\n   (apply swap! (:state env) update-in (:ref env) ...)\n   ```\n   \"\n\n  [{:keys [state ref]} & args]\n  (apply swap! state update-in ref args))\n\n\n(defn update-caller-in!\n  \"Like swap! but starts at the ref from `env`, adds in supplied `path` elements\n  (resolving across idents if necessary). Finally runs an update-in on that resultant\n  path with the given `args`.\n\n   Equivalent to:\n   ```\n   (swap! (:state env) update-in (tree-path->db-path @state (into (:ref env) path)) args)\n   ```\n   with a small bit of additional sanity checking.\"\n\n  [{:keys [state ref] :as mutation-env} path & args]\n  (let [path (tree-path->db-path @state (into ref path))]\n    (if (and path (get-in-graph @state path))\n      (apply swap! state update-in path args)\n      @state)))\n\n#?(:clj\n   (defmacro swap!->\n     \"A useful macro for threading multiple operations together on an atom (e.g. state atom in mutation)\n\n     Equivalent to:\n     ```\n     (swap! atom (fn [s] (-> s ...forms...)))\n     ```\n\n     For example\n\n     ```\n     (swap!-> (:state env)\n       (merge/merge-component ...)\n       (integrate-ident* ...))\n     ```\n     \"\n     [atom & forms]\n     `(swap! ~atom (fn [s#] (-> s# ~@forms)))))\n"]}