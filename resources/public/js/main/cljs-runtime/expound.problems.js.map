{"version":3,"sources":["expound/problems.cljc"],"mappings":"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","names":["expound.problems/adjust-in","form","problem","in1","expound.paths/in-with-kps","in2","paths","expound.paths/paths-to-value","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/count","cljs.core/first","in3","e42300","cljs.spec.alpha/unform","cljs.core/last","_e","new-in","or__4131__auto__","G__42304","fexpr__42303","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","expound.problems/adjust-path","failure","and__4120__auto__","G__42316","fexpr__42315","cljs.core/vec","cljs.core/rest","expound.problems/add-spec","spec","expound.problems/fix-via","cljs.core.into.cljs$core$IFn$_invoke$arity$2","expound.problems/missing-spec?","_failure","expound.problems/not-in-set?","cljs.core/set?","expound.problems/fspec-exception-failure?","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","expound.problems/fspec-ret-failure?","expound.problems/fspec-fn-failure?","expound.problems/check-ret-failure?","expound.problems/check-fn-failure?","expound.problems/missing-key?","pred","cljs.core/seq?","cljs.spec.alpha.valid_QMARK_.cljs$core$IFn$_invoke$arity$2","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","expound.problems/insufficient-input?","cljs.core/contains?","expound.problems/extra-input?","cljs.spec.alpha/def-impl","cljs.spec.alpha/fspec-impl","cljs.spec.alpha.spec_impl.cljs$core$IFn$_invoke$arity$4","cljs.core/any?","cljs.spec.alpha/cat-impl","cljs.spec.alpha/nilable-impl","cljs.core/boolean?","expound.problems/ptype","skip-locations?","cljs.core/not","expound.problems/annotate","explain-data","map__42375","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","problems","value","args","ret","fn","caller","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2","problems'","cljs.core.map.cljs$core$IFn$_invoke$arity$2","p1__42372#","p1__42373#","cljs.core.comp.cljs$core$IFn$_invoke$arity$variadic","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","expound.problems/type","expound.problems/value-in","expound.paths/value-in"],"sourcesContent":["(ns ^:no-doc expound.problems\n  (:require [expound.paths :as paths]\n            [clojure.spec.alpha :as s])\n  (:refer-clojure :exclude [type]))\n\n;; can simplify when \n;; https://dev.clojure.org/jira/browse/CLJ-2192 or\n;; https://dev.clojure.org/jira/browse/CLJ-2258 are fixed\n(defn- adjust-in [form problem]\n  ;; Three strategies for finding the value...\n  (let [;; 1. Find the original value\n        in1 (paths/in-with-kps form (:val problem) (:in problem) [])\n\n        ;; 2. If value is unique, just find that, ignoring the 'in' path\n        in2 (let [paths (paths/paths-to-value form (:val problem) [] [])]\n              (if (= 1 (count paths))\n                (first paths)\n                nil))\n\n        ;; 3. Find the unformed value (if there is an unformer)\n        in3 (try\n              (paths/in-with-kps form\n                                 (s/unform (last (:via problem)) (:val problem))\n                                 (:in problem) [])\n              ;; The unform fails if there is no unformer\n              ;; and the unform function could throw any type of\n              ;; exception (it's provided by user)\n              (catch #?(:cljs :default\n                        :clj java.lang.Throwable) _e\n                nil))\n        new-in (cond in1\n                     in1\n\n                     in2\n                     in2\n\n                     in3\n                     in3\n\n                     (or (= '(apply fn) (:pred problem))\n                         (#{:ret} (first (:path problem))))\n                     (:in problem)\n\n                     :else\n                     nil)]\n\n    (assoc problem\n           :expound/in\n           new-in)))\n\n(defn- adjust-path [failure problem]\n  (assoc problem :expound/path\n         ;; Orchestra 2019.02.06-1 prefixed the path, but as of 2020.07.12-1, it is not included\n         (if (and (= :instrument failure) (#{:ret :args} (first (:path problem))))\n           (vec (rest (:path problem)))\n           (:path problem))))\n\n(defn- add-spec [spec problem]\n  (assoc problem :spec spec))\n\n;; via is slightly different when using s/assert\n(defn fix-via [spec problem]\n  (if (= spec (first (:via problem)))\n    (assoc problem :expound/via (:via problem))\n    (assoc problem :expound/via (into [spec] (:via problem)))))\n\n(defn ^:private missing-spec? [_failure problem]\n  (= \"no method\" (:reason problem)))\n\n(defn ^:private not-in-set? [_failure problem]\n  (set? (:pred problem)))\n\n(defn ^:private fspec-exception-failure? [failure problem]\n  (and (not= :instrument failure)\n       (not= :check-failed failure)\n       (= '(apply fn) (:pred problem))))\n\n(defn ^:private fspec-ret-failure? [failure problem]\n  (and\n   (not= :instrument failure)\n   (not= :check-failed failure)\n   (= :ret (last (:path problem)))))\n\n(defn ^:private fspec-fn-failure? [failure problem]\n  (and\n   (not= :instrument failure)\n   (not= :check-failed failure)\n   (= :fn (last (:path problem)))))\n\n(defn ^:private check-ret-failure? [failure problem]\n  (and\n   (= :check-failed failure)\n   (= :ret (last (:path problem)))))\n\n(defn ^:private check-fn-failure? [failure problem]\n  (and (= :check-failed failure)\n       (= :fn (last (:path problem)))))\n\n(defn ^:private missing-key? [_failure problem]\n  (let [pred (:pred problem)]\n    (and (seq? pred)\n         (< 2 (count pred))\n         (s/valid?\n          :expound.spec/contains-key-pred\n          (nth pred 2)))))\n\n(defn ^:private insufficient-input? [_failure problem]\n  (contains? #{\"Insufficient input\"} (:reason problem)))\n\n(defn ^:private extra-input? [_failure problem]\n  (contains? #{\"Extra input\"} (:reason problem)))\n\n(s/fdef ptype\n  :args (s/cat :failure (s/nilable #{:instrument :check-failed :assertion-failed})\n               :problem :expound.spec/problem\n               :skip-location? boolean?))\n(defn ^:private ptype [failure problem skip-locations?]\n  (cond\n    (:expound.spec.problem/type problem)\n    (:expound.spec.problem/type problem)\n\n    ;; This is really a location of a failure, not a failure type\n    (and (not skip-locations?) (fspec-ret-failure? failure problem))\n    :expound.problem/fspec-ret-failure\n\n    (fspec-exception-failure? failure problem)\n    :expound.problem/fspec-exception-failure\n\n    ;; This is really a location of a failure, not a failure type\n    ;; (compare to check-fn-failure, which is also an fn failure, but\n    ;; at a different location)\n    (and (not skip-locations?) (fspec-fn-failure? failure problem))\n    :expound.problem/fspec-fn-failure\n\n    ;; This is really a location of a failure, not a failure type\n    (and (not skip-locations?) (check-ret-failure? failure problem))\n    :expound.problem/check-ret-failure\n\n    ;; This is really a location of a failure, not a failure type\n    (and (not skip-locations?) (check-fn-failure? failure problem))\n    :expound.problem/check-fn-failure\n\n    (insufficient-input? failure problem)\n    :expound.problem/insufficient-input\n\n    (extra-input? failure problem)\n    :expound.problem/extra-input\n\n    (not-in-set? failure problem)\n    :expound.problem/not-in-set\n\n    (missing-key? failure problem)\n    :expound.problem/missing-key\n\n    (missing-spec? failure problem)\n    :expound.problem/missing-spec\n\n    :else\n    :expound.problem/unknown))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;; public ;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defn annotate [explain-data]\n  (let [{::s/keys [problems value args ret fn failure spec]} explain-data\n        caller (or (:clojure.spec.test.alpha/caller explain-data) (:orchestra.spec.test/caller explain-data))\n        form (if (not= :instrument failure)\n               value\n               (cond\n                 (contains? explain-data ::s/ret) ret\n                 (contains? explain-data ::s/args) args\n                 (contains? explain-data ::s/fn) fn\n                 :else (throw (ex-info \"Invalid explain-data\" {:explain-data explain-data}))))\n        problems' (map (comp (partial adjust-in form)\n                             (partial adjust-path failure)\n                             (partial add-spec spec)\n                             (partial fix-via spec)\n                             #(assoc % :expound/form form)\n                             #(assoc % :expound.spec.problem/type (ptype failure % false)))\n                       problems)]\n\n    (-> explain-data\n        (assoc :expound/form form\n               :expound/caller caller\n               :expound/problems problems'))))\n\n(def type ptype)\n\n;; Must keep this function here because\n;; spell-spec uses it\n;; https://github.com/bhauman/spell-spec/blob/48ea2ca544f02b04a73dc42a91aa4876dcc5fc95/src/spell_spec/expound.cljc#L20\n(def value-in paths/value-in)\n"]}